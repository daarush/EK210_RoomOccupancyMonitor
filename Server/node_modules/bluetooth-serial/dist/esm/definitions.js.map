{"version":3,"file":"definitions.js","sourceRoot":"","sources":["../../src/definitions.ts"],"names":[],"mappings":"AAqHA,MAAM,CAAN,IAAY,eAEX;AAFD,WAAY,eAAe;IACzB,qDAAI,CAAA;IAAE,iEAAU,CAAA;IAAE,+DAAS,CAAA;AAC7B,CAAC,EAFW,eAAe,KAAf,eAAe,QAE1B","sourcesContent":["import type { PermissionState, PluginListenerHandle } from \"@capacitor/core\";\n\nexport interface BluetoothSerialPlugin {\n  echo(options: { value: string }): Promise<{ value: string }>;\n  /**\n   * Creates a secure connection (https://developer.android.com/reference/android/bluetooth/BluetoothDevice#createRfcommSocketToServiceRecord(java.util.UUID)) to the bluetooth device with the given address.\n   * The plugin only retains one connection at a time; upon connecting to a device, while there is already an existing connection,\n   * the previous device is disconnected. If there is already a running connect call that hasn't resolved, and a new one starts, the original will reject with \"Connection interrupted\".\n   * Requires CONNECT permission on Android API >= 30\n   */\n  connect(options: connectionOptions): Promise<void>;\n  /**\n   * Creates an insecure connection (https://developer.android.com/reference/android/bluetooth/BluetoothDevice#createInsecureRfcommSocketToServiceRecord(java.util.UUID)) to the bluetooth device with the given address.\n   * The plugin only retains one connection at a time; upon connecting to a device, while there is already an existing connection,\n   * the previous device is disconnected. If there is already a running connect call that hasn't resolved, and a new one starts, the original will reject with \"Connection interrupted\".\n   * Requires CONNECT permission on Android API >= 30\n   */\n  connectInsecure(options: connectionOptions): Promise<void>;\n  /**\n   * Disconnects from the currently connected device.\n   * This may be called while there is no connected device; in that case, the method will resolve with void.\n   */\n  disconnect(): Promise<void>;\n  /**\n   * Returns data emitted from the currently connected device.\n   */\n  read(): Promise<{ data: string }>;\n  /**\n   * Writes data to the currently connected device.\n   */\n  write(options: { data: string }): Promise<void>;\n  /**\n   * Returns the length of the data that can be read by calling read().\n   */\n  available(): Promise<{ available: number }>;\n  /**\n   * Returns true or false depending on whether bluetooth is enabled.\n   */\n  isEnabled(): Promise<{ isEnabled: boolean }>;\n  /**\n   * Returns true or false depending on whether the plugin is currently connected to a device.\n   */\n  isConnected(): Promise<{ isConnected: boolean }>;\n  /**\n   * Clears the data readable by calling read().\n   */\n  clear(): Promise<void>;\n  /**\n   * Displays the native prompt for enabling bluetooth. Returns true or false depending on whether the user enabled bluetooth.\n   * Requires CONNECT permission on Android API >= 30\n   */\n  enable(): Promise<{ isEnabled: boolean }>;\n  /**\n   * Opens the native bluetooth settings activity. Resolves immediately upon being called.\n   */\n  settings(): Promise<void>;\n  /**\n   * Returns a list of bonded devices. This includes devices that were previously paired with the user's device\n   * Requires CONNECT permission on Android API >= 30\n   */\n  list(): Promise<devices>;\n  /**\n   * Begins the discovery of nearby devices and resolves with them once discovery is finished.\n   * There may only be one discovery process at a time. If another call starts while there is a discovery in progress,\n   * the original call will resolve with \"Discovery cancelled\".\n   * \n   * On Android API >= 30 requires SCAN, CONNECT and FINE_LOCATION permissions.\n   * You can declare in your manifest that scanning for devices is not used to derive the user's location. In that case, you may also\n   * add the following into your capacitor.config.ts to indicate that the plugin should not require FINE_LOCATION:\n   * \n   * BluetoothSerial: {\n   *  neverScanForLocation: true,\n   * }\n   * \n   * In that case, only SCAN and CONNECT are required.\n   * \n   * On Android 10 and 11, only FINE_LOCATION is required.\n   * \n   * On lower versions, only COARSE_LOCATION is required.\n   * \n   * The versions of Android that require location permissions, also require location services to be enabled.\n   * So this plugin will reject with \"Location services not enabled\" if the device requires location for scanning, but it is disabled.\n   * \n   * https://developer.android.com/guide/topics/connectivity/bluetooth/permissions\n   */\n  discoverUnpaired(): Promise<devices>;\n  /**\n   * Cancels current unpaired devices discovery, if there is one in progress. If there is no discovery in progress, resolves with void.\n   * Be sure to note that calling this will reject any existing discoverUnpaired() call which hasn't resolved yet.\n   * Requires SCAN permission on Android API >= 30\n   */\n  cancelDiscovery(): Promise<void>;\n  /**\n   * Takes into account the fact that SCAN and CONNECT permissions only exist on Android 11+; those permissions will always resolve as GRANTED\n   * on devices below Android 11.\n   */\n  checkPermissions(): Promise<PermissionStatus[]>;\n  /**\n   * Takes into account the fact that SCAN and CONNECT permissions only exist on Android 11+; those permissions will always resolve as GRANTED\n   * on devices below Android 11.\n   */\n  requestPermissions(options: { permissions: permissions[] }): Promise<PermissionStatus[]>;\n  addListener(event: 'discoverUnpaired', listenerFunc: (event: devices) => any): Promise<PluginListenerHandle> & PluginListenerHandle;\n  addListener(event: 'connectionChange', listenerFunc: (event: { state: ConnectionState }) => any): Promise<PluginListenerHandle> & PluginListenerHandle;\n  removeAllListeners(): Promise<void>;\n}\n\nexport interface BluetoothDevice {\n  address: string;\n  name?: string;\n  // you may use this property to conclude what sort of device the connected device is\n  deviceClass?: number;\n}\n\nexport type permissions = 'coarseLocation' | 'fineLocation' | 'scan' | 'connect';\nexport type PermissionStatus = { [permission in permissions]?: PermissionState };\nexport type devices = { devices: BluetoothDevice[] };\nexport enum ConnectionState {\n  NONE, CONNECTING, CONNECTED,\n}\ntype connectionOptions = { address: string };"]}